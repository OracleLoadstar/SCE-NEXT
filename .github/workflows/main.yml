name: 构建并发布 WinUI 应用 (使用 Start-Process 优化 MSBuild 调用)

on:
  push:
    branches:
      - main
  create:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - name: ⬇️ 检出代码
        uses: actions/checkout@v4

      - name: ⚙️ 设置 .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x' 

      - name: 🛠️ 通过 Chocolatey 安装 Visual Studio Build Tools 及所需组件
        run: |
          Write-Host "ℹ️ 检查 Chocolatey 是否已安装..."
          choco -?
          Write-Host "✅ Chocolatey 已可用。"

          $vsInstallerArguments = @(
              "--installPath", "D:\VSBuildTools",
              "--add", "Microsoft.VisualStudio.Workload.UniversalPlatform",
              "--add", "Microsoft.VisualStudio.Workload.VCTools",
              "--add", "Microsoft.VisualStudio.Component.Windows10SDK.26100",
              "--add", "Microsoft.VisualStudio.Component.VC.Redist.14.Latest",
              "--add", "Microsoft.VisualStudio.Component.Roslyn.Compiler",
              "--add", "Microsoft.Net.Component.DotNetBuildTools.6.0",
              "--add", "Microsoft.Net.Component.4.7.2.TargetingPack",
              "--add", "Microsoft.VisualStudio.Component.DesktopBridge",
              "--includeRecommended",
              "--quiet",     # 静默安装
              "--norestart"  # 禁止安装后重启
          ) -join ' '

          Write-Host "ℹ️ 传递给 Chocolatey 的原始 VS 安装参数字符串: '$vsInstallerArguments'"

          choco install visualstudio2022buildtools --params "'$vsInstallerArguments'" --yes --force --timeout-minutes=50

          Write-Host "✅ Chocolatey 安装 Visual Studio Build Tools 完成。"
        shell: pwsh
        timeout-minutes: 60 

      - name: 🔍 验证 Visual Studio 安装并设置 MSBuild 环境变量
        id: setup_msbuild_env
        run: |
          $vsPath = "D:\VSBuildTools" 
          
          if (-not (Test-Path $vsPath)) {
              Write-Error "❌ 错误: Visual Studio Build Tools 2022 未安装在预期的路径: $vsPath"
              Write-Host "请检查 Chocolatey 安装日志，确认安装是否成功以及实际安装位置。"
              exit 1
          }
          
          Write-Host "✅ 步骤: Visual Studio Build Tools 2022 安装路径: $vsPath"

          $msbuildPath = Join-Path $vsPath "MSBuild\Current\Bin\MSBuild.exe"
          if (-not (Test-Path $msbuildPath)) {
              $msbuildPath = Join-Path $vsPath "MSBuild\17.0\Bin\MSBuild.exe" 
          }
          
          Write-Host "✅ 步骤: 查找 MSBuild.exe..."
          if (-not (Test-Path $msbuildPath)) {
              Write-Error "❌ 错误: 未能找到新安装的 MSBuild.exe。请检查安装路径和结构。"
              Get-ChildItem -Path $vsPath -Recurse -Depth 3 -ErrorAction SilentlyContinue | Select-Object FullName, Attributes, LastWriteTime | Format-Table -AutoSize
              exit 1
          }
          
          echo "msbuild_path=$msbuildPath" >> $env:GITHUB_OUTPUT
          
          $vsDevCmdPath = Join-Path $vsPath "Common7\Tools\VsDevCmd.bat"
          if (-not (Test-Path $vsDevCmdPath)) {
              $vsDevCmdPath = Join-Path $vsPath "VC\Auxiliary\Build\vcvarsall.bat"
          }
          
          Write-Host "✅ 步骤: 查找 VsDevCmd.bat 或 vcvarsall.bat..."
          if (-not (Test-Path $vsDevCmdPath)) {
              Write-Error "❌ 错误: 未能找到 VsDevCmd.bat 或 vcvarsall.bat。无法正确配置 Visual Studio 构建环境。"
              exit 1
          }
          echo "vs_dev_cmd_path=$vsDevCmdPath" >> $env:GITHUB_OUTPUT
          
          echo "##vso[task.prependpath]$($msbuildPath | Split-Path -Parent)"
          echo "VSCMD_START_DIR=$vsPath" | Out-File -FilePath $env:GITHUB_ENV -Append
          
          Write-Host "✅ 步骤: MSBuild 已添加到 PATH: $($msbuildPath | Split-Path -Parent)"
          Write-Host "✅ 步骤: VSCMD_START_DIR 已设置: $vsPath"
          Write-Host "✅ 步骤: MSBuild 路径已作为输出变量 'msbuild_path' 导出。"
          Write-Host "✅ 步骤: VsDevCmd.bat 路径已作为输出变量 'vs_dev_cmd_path' 导出。"
        shell: pwsh

      - name: 🧹 清理 NuGet 全局缓存 (可选)
        run: dotnet nuget locals all --clear
        shell: pwsh

      - name: 📦 恢复项目依赖 (使用 Start-Process 调用 MSBuild)
        run: |
          $repoPath = "${{ github.workspace }}"
          Set-Location -Path $repoPath
          Write-Host "✅ 已将工作目录更改为: $(Get-Location)"
          
          Write-Host "🔍 验证 App2.sln 在当前目录的存在..."
          Get-ChildItem -Path . | Format-Table -AutoSize
          if (-not (Test-Path "App2.sln")) {
              Write-Error "❌ 错误: App2.sln 未在当前目录找到。请检查文件是否存在或路径是否正确。"
              exit 1
          }
          Write-Host "✅ App2.sln 已确认存在于当前目录。"

          # ⭐ 核心修改：构建命令字符串并使用 Start-Process
          $command = "call `"${{ steps.setup_msbuild_env.outputs.vs_dev_cmd_path }}`" && `"${{ steps.setup_msbuild_env.outputs.msbuild_path }}`" App2.sln /t:restore"
          Write-Host "ℹ️ 正在执行命令: $command"
          
          # 使用 Start-Process 执行命令，确保在 cmd.exe 环境中运行
          Start-Process -FilePath "cmd.exe" -ArgumentList "/c", $command -NoNewWindow -Wait -ErrorAction Stop
          Write-Host "✅ MSBuild 恢复项目依赖完成。"
        shell: pwsh

      - name: 🚀 编译并打包 WinUI 应用为 MSIX (使用 Start-Process 调用 MSBuild)
        run: |
          $repoPath = "${{ github.workspace }}"
          Set-Location -Path $repoPath
          Write-Host "✅ 已将工作目录更改为: $(Get-Location)"

          Write-Host "🔍 验证 App2.sln 在当前目录的存在..."
          Get-ChildItem -Path . | Format-Table -AutoSize
          if (-not (Test-Path "App2.sln")) {
              Write-Error "❌ 错误: App2.sln 未在当前目录找到。请检查文件是否存在或路径是否正确。"
              exit 1
          }
          Write-Host "✅ App2.sln 已确认存在于当前目录。"

          # ⭐ 核心修改：构建命令字符串并使用 Start-Process
          $command = "call `"${{ steps.setup_msbuild_env.outputs.vs_dev_cmd_path }}`" && `"${{ steps.setup_msbuild_env.outputs.msbuild_path }}`" App2.sln /p:Configuration=Release /p:Platform="x64" /p:AppxBundle=Always /p:AppxBundlePlatforms="x64" /p:UapAppxPackageBuildMode=StoreUpload"
          Write-Host "ℹ️ 正在执行命令: $command"

          # 使用 Start-Process 执行命令，确保在 cmd.exe 环境中运行
          Start-Process -FilePath "cmd.exe" -ArgumentList "/c", $command -NoNewWindow -Wait -ErrorAction Stop
          Write-Host "✅ MSBuild 编译并打包 WinUI 应用完成。"
        shell: pwsh 

      - name: 🔍 查找 MSIX 安装包
        id: find_msix
        run: |
          $repoPath = "${{ github.workspace }}"
          Set-Location -Path $repoPath
          Write-Host "✅ 已将工作目录更改为: $(Get-Location)"

          $msixPath = Get-ChildItem -Path ".\**\*.msix" -Recurse | Where-Object { $_.FullName -like "*AppPackages*" -or $_.DirectoryName -like "*bin\Release*" } | Select-Object -ExpandProperty FullName | Select-Object -First 1
          if ($msixPath) {
              echo "msix_path=$msixPath" >> $env:GITHUB_OUTPUT
              Write-Host "✅ 已找到 MSIX 安装包: $msixPath"
          } else {
              Write-Error "❌ 未找到 MSIX 安装包。请检查你的项目构建输出路径和 MSBuild 参数。"
              exit 1
          }
        shell: pwsh

      - name: ⬆️ 上传 MSIX 作为工作流产物
        uses: actions/upload-artifact@v4
        with:
          name: SCE-NEXT-MSIX-Package
          path: ${{ steps.find_msix.outputs.msix_path }}

      - name: ✨ 创建 GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false

      - name: 📤 上传 MSIX 到 Release 资产
        if: startsWith(github.ref, 'refs/tags/') && steps.find_msix.outputs.msix_path
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.find_msix.outputs.msix_path }}
          asset_name: SCE-NEXT.msix
          asset_content_type: application/msix
